using System;
using System.Collections.Generic;
using System.Text;

namespace NonogramGame
{
	class PlayerNonogram : Nonogram
	{
		public bool[,] markBoard;
		public bool[,] crossBoard;

		static string cross = "><";

		public PlayerNonogram(int size) : base(size)
		{
			markBoard = new bool[size, size];
			crossBoard = new bool[size, size];
		}

		public override List<int>[] genVertHints()
		{
			if(markBoard == null) return base.genVertHints();

			List<int>[] hints = new List<int>[markBoard.GetLength(0)]; // new int[markBoard.GetLength(0)][];

			for(int j = 0; j < markBoard.GetLength(0); j++)
			{
				bool inSeq = false;
				int length = 0;

				List<int> hint = new List<int>();

				for(int i = 0; i < markBoard.GetLength(0); i++)
				{
					if(markBoard[i, j])
					{
						if(!inSeq) inSeq = true;

						length++;
					}
					else if(inSeq)
					{
						inSeq = false;

						hint.Add(length);
						length = 0;
					}
				}

				if(inSeq) hint.Add(length);

				if(hint.Count == 0) hint.Add(0);

				hints[j] = hint;
			}

			return hints;
		}

		public override List<int>[] genHorzHints()
		{
			if(markBoard == null) return base.genHorzHints();

			List<int>[] hints = new List<int>[markBoard.GetLength(0)]; //new int[markBoard.GetLength(0)][];

			for(int i = 0; i < markBoard.GetLength(0); i++)
			{
				bool inSeq = false;
				int length = 0;

				List<int> hint = new List<int>();

				for(int j = 0; j < markBoard.GetLength(0); j++)
				{
					if(markBoard[i, j])
					{
						if(!inSeq) inSeq = true;

						length++;
					}
					else if(inSeq)
					{
						inSeq = false;

						hint.Add(length);
						length = 0;
					}
				}

				if(inSeq) hint.Add(length);

				if(hint.Count == 0) hint.Add(0);

				hints[i] = hint;
			}

			return hints;
		}

		public override string ToString()
		{
			// TODO: Update parent class to have divisors
			
			StringBuilder sb = new StringBuilder();

			for(int i = 0; i < board.GetLength(0); i++)
			{
				// Add Horizontal Divisor Every 5
				if(0 == i % 5)
				{
					for(int j = 0; j < board.GetLength(0); j++)
					{
						if(0 == j % 5) sb.Append("--");
						sb.Append("--");
					}

					sb.AppendLine();
				}

				// Print Board at Row
				for(int j = 0; j < board.GetLength(0); j++)
				{
					// Add Vertical Divisor Every 5
					if(0 == j % 5) sb.Append("||");
					
					// Print Board State at Point
					if(markBoard[i, j]) sb.Append(block + "" + block);
					else if(crossBoard[i, j]) sb.Append(cross);
					else sb.Append("  ");
				}

				sb.Append(" ");

				// Print Horizontal Hints
				for(int j = 0; j < horzHints[i].Count; j++)
				{
					sb.Append(horzHints[i][j] + " ");
				}
				
				sb.AppendLine();
			}

			// Print Vertical Hints
			bool didPrint;
			int k = 0;
			do
			{
				didPrint = false;

				for(int i = 0; i < board.GetLength(0); i++)
				{
					if(0 == i % 5) sb.Append("  ");

						if(k < vertHints[i].Count)
					{
						if(vertHints[i][k] < 10) sb.Append(" ");
						sb.Append(vertHints[i][k]);

						didPrint = true;
					}
					else sb.Append("  ");
				}

				sb.AppendLine();

				k++;
			}
			while(didPrint);

			return sb.ToString();
		}

		public void Mark(int x, int y)
		{
			crossBoard[y, x] = false;
			markBoard[y, x] = !markBoard[y, x];
		}

		public void Cross(int x, int y)
		{
			crossBoard[y, x] = !crossBoard[y, x];
			markBoard[y, x] = false;
		}

		public void Clear(int x, int y)
		{
			crossBoard[y, x] = false;
			markBoard[y, x] = false;
		}

		public bool IsSolved()
		{
			// Get the Hints Generated by the markings
			List<int>[] horzMark = genHorzHints();
			List<int>[] vertMark = genVertHints();

			// Do Comparison
			bool same = true;
			for(int i = 0; i < markBoard.GetLength(0); i++)
			{
				// Check Horizontally
				for(int j = 0; j < horzMark[i].Count; j++)
				{
					try
					{
						if(horzMark[i][j] != horzHints[i][j])
						{
							same = false;
							break;
						}
					}
					catch(Exception e)
					{
						same = false;
						break;
					}
				}

				if(!same) break;

				// Check Vertically
				for(int j = 0; j < vertMark[i].Count; j++)
				{
					try
					{
						if(vertMark[i][j] != vertHints[i][j])
						{
							same = false;
							break;
						}
					}
					catch(Exception e)
					{
						same = false;
						break;
					}
				}

				if(!same) break;
			}

			return same;
		}
	}
}
